#!/bin/bash
set -euo pipefail

FETCH="${FETCH-1}"
SCRIPTFOLDER="$(dirname "$(readlink -f "$0")")"

if [ $# -lt 1 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
  echo "Usage: $0 OLD [NEW]"
  echo "Shows the changes between the git references by assembling the changelog/ folder entries"
  echo "Should be run in the folder that contains the coreos-overlay, portage-stable, and scripts repository folders."
  echo "The NEW reference can be omitted and will then default to HEAD."
  exit 1
fi

OLD="$1"
NEW="${2-HEAD}"
OLD_FMT=""

# The release tags are usually in format of (alpha|beta|stable|lts-XXXX.Y.Z) but
# what we need in the formatted output is (Alpha|Beta|Stable|LTS XXXX.Y.Z).
# The given code transform the given name into the desired output.
if [[ $OLD == *"lts"* ]]; then
  OLD_FMT=$(echo $OLD | tr "-" " " | tr '[:lower:]' '[:upper:]')
else
  OLD_FMT=$(echo $OLD | tr "-" " " | sed 's/./\U&/')
fi

echo "_Changes since **${OLD_FMT}**_"

for section in security bugfixes changes updates; do
  echo
  case "${section}" in
    security)
      echo "#### Security fixes:"
      ;;
    bugfixes)
      echo "#### Bug fixes:"
      ;;
    changes)
      echo "#### Changes:"
      ;;
    updates)
      echo "#### Updates:"
      ;;
    *)
      echo "wrong cases" > /dev/stderr
      exit 1
  esac
  echo
  for repo in coreos-overlay portage-stable scripts; do
    if [ "${repo}" = scripts ] && [ ! -e "${repo}" ]; then
      # Support the previous repo name for old checkouts
      repo="flatcar-scripts"
    fi
    OLDREF="${OLD}"
    NEWREF="${NEW}"
    REPOPATH="${repo}"
    # For the submodule detection, assume that the "scripts" repo name is ok
    if [ "${repo}" != "scripts" ] && [ -d "scripts/sdk_container/src/third_party/${repo}" ]; then
      if [ "${FETCH}" = 1 ]; then
        git -C "scripts" fetch -t -f 2> /dev/null > /dev/null || { echo "Error: git fetch -t -f failed" ; exit 1 ; }
      fi
      # Find the pinned submodule refs because there may be no release tags inside the submodules
      # Pipe to awk instead of using --object-only for git 2.35 support
      OLDREF=$(git -C "scripts" ls-tree "${OLD}" "sdk_container/src/third_party/${repo}" | awk '{print $3 }')
      NEWREF=$(git -C "scripts" ls-tree "${NEW}" "sdk_container/src/third_party/${repo}" | awk '{print $3 }')
      REPOPATH="scripts/sdk_container/src/third_party/${repo}"
    fi
    if [ "${FETCH}" = 1 ]; then
      git -C "${REPOPATH}" fetch -t -f 2> /dev/null > /dev/null || { echo "Error: git fetch -t -f failed" ; exit 1 ; }
    fi
    if [ "${section}" = "security" ] && [ "${repo}" = "coreos-overlay" ]; then
      FROM_KERNEL=$(git -C "${REPOPATH}" show "${OLDREF}":sys-kernel/coreos-kernel/ | grep -m 1 'coreos-kernel-.*\.ebuild' | cut -d - -f 3 | cut -d . -f 1-3)
      TO_KERNEL=$(git -C "${REPOPATH}" show "${NEWREF}":sys-kernel/coreos-kernel/ | grep -m 1 'coreos-kernel-.*\.ebuild' | cut -d - -f 3 | cut -d . -f 1-3)
      if [ "${FROM_KERNEL}" != "${TO_KERNEL}" ]; then
        KERNEL_ENTRIES=$("${SCRIPTFOLDER}"/show-fixed-kernel-cves.py -f "${FROM_KERNEL}" -t "${TO_KERNEL}")
        if [ "${KERNEL_ENTRIES}" != "" ]; then
          echo "- Linux (${KERNEL_ENTRIES})"
        fi
      fi
    fi
    git -C "${REPOPATH}" difftool --no-prompt --extcmd='sh -c "cat \"$REMOTE\"" --' "${OLDREF}..${NEWREF}" -- "changelog/${section}/" | sort || { echo "Error: git difftool failed" ; exit 1 ; }
    # The -x 'sh -c "cat \"$REMOTE\"" --' command assumes that new changes have their own changelog files,
    # and thus ignores the LOCAL file (which is the empty /dev/null) and prints out the REMOTE completly.
    # If an existing file got changed, we assume that this is just a correction for the old change but
    # shouldn't be included in the release notes again.
  done
done
